# -*- coding: utf-8 -*-
"""stock pred.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JpSzmos6o6NqOYoLOGrntzDBJofSJIyx
"""

import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns
plt.style.use("seaborn")

data = pd.read_csv("NIFTY 50.csv", parse_dates = ["Date"], index_col = "Date")
data.info()

df = pd.DataFrame(data, columns=['Close'])
#df = df.reset_index()
df["Return"] = df.Close.pct_change()
df.dropna(inplace = True)
df

df.Close.rolling(window = 50).mean()

df["SMA50"] = df.Close.rolling(window = 50).mean()

df[["Close", "SMA50"]].plot(figsize = (15,10), fontsize = 15)
plt.legend(fontsize = 15)
plt.show()

df["SMA200"] = df.Close.rolling(window = 200).mean()

df[["Close", "SMA50", "SMA200"]].plot(figsize = (15,10), fontsize = 15)
plt.legend(fontsize = 15)
plt.show()

df.dropna(inplace = True)
df["Position"] = np.sign(df.SMA50.sub(df.SMA200))
df

df[["SMA50", "SMA200", "Position"]].plot(figsize = (15,10), secondary_y = "Position", fontsize = 15)
plt.show()

df["Strategy_Return"] = df["Position"].shift() * df["Return"]

from sklearn.model_selection import train_test_split

train, test = train_test_split(df, test_size=0.10)

from sklearn.linear_model import LinearRegression
from sklearn.svm import SVR
from sklearn.ensemble import RandomForestRegressor
from sklearn.preprocessing import PolynomialFeatures

poly = PolynomialFeatures(degree=5, include_bias=False)

X_train = np.array(train.index).reshape(-1, 1)
y_train = train['Close']

poly_features = poly.fit_transform(X_train.reshape(-1,1))

poly_features = poly.fit_transform(X_train.reshape(-1,1))

from pandas.core.common import random_state
model = LinearRegression()
svr_poly = SVR(kernel="rbf", C=100, gamma="auto")
#model_rf = RandomForestRegressor(n_estimators=500, oob_score=True, random_state=100)
# Fit linear model using the train data set
model.fit(poly_features, y_train)
fitting = model.predict(poly_features)
#model_rf.fit(X_train, y_train)
fitting

plt.figure(1, figsize=(16,10))
plt.title('Linear Regression | Price vs Time')
plt.scatter(X_train, y_train, edgecolor='w', label='Actual Price')
plt.plot(X_train, fitting, color='r', label='Predicted Price')
plt.legend()
plt.show()

data

df = data
df = df.reset_index()

df = df.drop(['Date', 'P/E', 'P/B',	'Div Yield', 'Turnover'], axis =1)
df

#ma100 = df.Close.rolling(100).mean
df["SMA50"] = df.Close.rolling(window = 100).mean()
df["SMA200"] = df.Close.rolling(window = 200).mean()

df_train = pd.DataFrame(df['Close'][0 : int(len(df)*0.70)])
df_test = pd.DataFrame(df['Close'][int(len(df)*0.70) : int(len(df))])

from sklearn.preprocessing import MinMaxScaler
scaler = MinMaxScaler(feature_range=(0,1))

df_train_arr = scaler.fit_transform(df_train)

x_train = []
y_train = []
for i in range(100, df_train_arr.shape[0]):
  x_train.append(df_train_arr[i-100: i])
  y_train.append(df_train_arr[i, 0])

x_train, y_train = np.array(x_train), np.array(y_train)

from keras.layers import Dense, Dropout, LSTM
from keras.models import Sequential

model = Sequential()
model.add(LSTM(units = 50, activation = 'relu', return_sequences=True, input_shape=(x_train.shape[1], 1)))
model.add(Dropout(0.2))

model.add(LSTM(units = 60, activation = 'relu', return_sequences=True))
model.add(Dropout(0.3))

model.add(LSTM(units = 80, activation = 'relu', return_sequences=True))
model.add(Dropout(0.4))

model.add(LSTM(units = 120, activation = 'relu'))
model.add(Dropout(0.5))

model.add(Dense(units = 1))

model.summary()

model.compile(optimizer='adam', loss='mean_squared_error')
model.fit(x_train, y_train, epochs=50)

model.save('keras_model.h5')

past_100 = df_train.tail(100)

final_df = past_100.append(df_test, ignore_index=True)

input_df = scaler.fit_transform(final_df)

x_test = []
y_test = []
for i in range(100, input_df.shape[0]):
  x_test.append(input_df[i-100: i])
  y_test.append(input_df[i, 0])

x_test, y_test = np.array(x_test), np.array(y_test)

y_pred = model.predict(x_test)

scaler.scale_

scale_fac = 1/0.00011225
y_pred = y_pred* scale_fac
y_test = y_test * scale_fac

plt.figure(figsize=(12, 6))
plt.plot(y_test, 'b', label='original price')
plt.plot(y_pred, 'r', label='predicted price')
plt.xlabel('time')
plt.ylabel('price')
plt.legend()
plt.show()

